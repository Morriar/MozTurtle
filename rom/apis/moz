-------------------------------------------------------
----- Moz API
----- v0.1
----- Tools & utils
-------------------------------------------------------

-----
-- class App
-----

App = {}
App.__index = App

function App.new()
    local app = utils.obj.new(App)

    -- attributes
    app.continue = true
    app.width = 0
    app.height = 0
    app.screens = {}
    app.hotkeys = {}
    app.hotkeys[14] = "back" -- backspace
    app.hotkeys[16] = "quit" -- [Q]uit
    app.namespace = "moznet"
    app.current_screen = nil
    app.back_screen = nil
    app.rednet = {}

    return app
end

function App:add_screen(screen)
    screen.app = self
    screen.width = self.width
    screen.height = self.height
    self.screens[screen.name] = screen
end

function App:display(screen_name)
    self.back_screen = self.current_screen
    self.current_screen = self.screens[screen_name]
    self.current_screen:render()
end

function App:refresh()
    self.current_screen:render()
end

function App:back()
    if self.current_screen ~= nil and self.current_screen.back_screen ~= nil then
	self:display(self.current_screen.back_screen)
    end
end

function App:quit()
    self.continue = false
    self.currentScreen:clear()
end

---
-- events
---

function App:listen()
    while(self.continue) do
	local event, p1, p2, p3 = os.pullEvent()
	self:handle_event(event, p1, p2, p3)
    end
end

-- handle event
function App:handle_event(event, p1, p2, p3)
    if self:event_handlers()[event] ~= nil then self:event_handlers()[event](p1, p2, p3) end
end

-- event handlers
function App:event_handlers()
    local handlers = {}

    handlers["key"] = function(key)
	self:handle_key_event(key)
    end

    handlers["rednet_message"] = function(sender, message, distance)
	self:event_rednet_handler(sender, message, distance)
    end

    return handlers
end

-- handle key event
function App:handle_key_event(key)
    -- hotkeys
    if self.hotkeys[key] ~= nil then
	utils.obj.call(self, self.hotkeys[key], {})
    else
	if self.current_screen ~= nil then
	    self.current_screen:handle_key_event(key)
	end
    end
end

-- handle rednet event
function App:event_rednet_handler(sender, serialized_message, distance)
    message = textutils.unserialize(serialized_message)
    if message == nil or message.namespace == nil or message.namespace ~= self.namespace then return end
    message.sender = sender
    message.distance = distance
    utils.obj.call(self, message.action, message)
end

-- rednet 

function App:rednet_message()
    message = {}
    message.namespace = self.namespace
    return message
end

-----
-- class Screen
-----

Screen = {}
Screen.__index = Screen

function Screen.new(name)
    local screen = utils.obj.new(Screen)

    -- attributes
    screen.name = name
    screen.width = nil
    screen.height = nil
    screen.panels = {}
    screen.app = nil
    screen.back_screen = nil
    screen.stdfocus = nil
    screen.current_panel = nil

    return screen
end

function Screen:clear()
    term.clear()
    term.setCursorPos(1, 1)
end

function Screen:render()
    self.clear()
    for name, panel in pairs(self.panels) do
	panel:render()
    end
    self:focus(self.stdfocus)
end

function Screen:focus(panel_name)
    panel = self.panels[panel_name]
    self.current_panel = panel
    self.current_panel:focus()
end

function Screen:add_panel(panel)
    print(panel.name)
    panel.screen = self
    self.panels[panel.name] = panel
end

function Screen:handle_key_event(key)
    self.current_panel:handle_key_event(key)
end

-----
-- class Panel
-----

Panel = {}
Panel.__index = Panel

function Panel.new(name, x, y, width, height)
    local panel = utils.obj.new(Panel)

    -- attributes
    panel.name = name
    panel.screen = nil
    panel.x = x
    panel.y = y
    panel.width = width
    panel.height = height
    panel.lines = {}
    panel.visible = true

    return panel
end

function Panel:clear()
    term.setCursorPos(self.x, self.y)
    for line = 1, self.height do
	for col = 1, self.width do
	    term.write(" ")
	end
	x, y = term.getCursorPos()
	term.setCursorPos(self.x, y + 1)
    end
end

function Panel:render()
    if not self.visible then return end
    self:refresh()
    term.setCursorPos(self.x, self.y)
    for line = 1, self.height do
	for col = 1, self.width do
	    if self.lines[line] ~= nil then
		if #self.lines[line] >= col then
		    term.write(self.lines[line]:sub(col, col))
		else
		    term.write(".")
		end
	    else
		term.write(".")
	    end
	end
	x, y = term.getCursorPos()
	term.setCursorPos(self.x, y + 1)
    end
end

-- set panel cotent as a array of lines
function Panel:refresh()
end

-- add text line to panel
function Panel:add_line(line)
    if #self.lines >= self.height then
	old = self.lines
	self.lines = {}
	for i = 2, #old do
		self.lines[i - 1] = old[i]
	end
    end
    self.lines[#self.lines + 1] = line
end

-- add text line to panel and refresh panel
function Panel:printl(line)
    self:add_line(line)
    self:render()
end

function Panel:focus()
    term.setCursorPos(self.x, self.y)
    term.setCursorBlink(true)
end

function Panel:handle_key_event(key)
    x, y = term.getCursorPos()

    if key == 200 then -- uparrow
	y = y - 1
    elseif key == 208 then  -- downarrow
	y = y + 1
    elseif key == 203 then  -- leftarrow
	x = x - 1
    elseif key == 205 then  -- rightarrow
	x = x + 1
    end

    if x < self.x then return end
    if y < self.y then return end
    if x > self.x + self.width - 1 then return end
    if y > self.y + self.height - 1 then return end

    term.setCursorPos(x, y)
end

-----
-- class Menu
-- 	super Panel
-----

Menu = {}
Menu.__index = Menu

function Menu.new(name, x, y, width, height, title)
   local super = Panel.new(name, x, y, width, height)
   local menu = utils.obj.new(Menu, super)
    
    -- local attributes
    menu.title = title
    menu.items = {}
    menu.title_margin = 1

    return menu
end

function Menu:render(params)
    if not self.visible then return end
    self:refresh()
    term.setCursorPos(self.x, self.y)
    term.write(self.title)
    term.setCursorPos(self.x, self.y + 1 + self.title_margin)
    
    for i, item in ipairs(self.items) do
	x, y = term.getCursorPos()
	term.setCursorPos(x + 3, y)
	term.write(item.label)
	term.setCursorPos(x, y + 1)
    end
end

function Menu:add_item(label, action, params)
    item = {}
    item.label = label
    item.action = action
    item.params = params
    self.items[#self.items + 1] = item
end

function Menu:focus()
    term.setCursorBlink(false)
    term.setCursorPos(self.x + 1, self.y + 1 + self.title_margin)
    term.write(">")
    term.setCursorPos(self.x + 1, self.y + 1 + self.title_margin)
end

function Menu:handle_key_event(key)
    local ymin = self.y + 1 + self.title_margin
    local ymax = ymin + #self.items

    -- arrow up
    if key == 200 then
	x, y = term.getCursorPos()
	y = y - 1
	if y >= ymin then
	    self:clear_cursor()
	    term.setCursorPos(x, y)
	    term.write(">")
	    term.setCursorPos(x, y)
	end
    end
    -- arrow down
    if key == 208 then
	x, y = term.getCursorPos()
	y = y + 1
	if y < ymax then
	    self:clear_cursor()
	    term.setCursorPos(x, y)
	    term.write(">")
	    term.setCursorPos(x, y)
	end
    end
    -- enter
    if key == 28 then
	x, y = term.getCursorPos()
	item = self.items[y - ymin + 1]
	utils.obj.call(self.screen.app, item.action, item.params)
    end
end

function Menu:clear_cursor()
    local ymin = self.y + 1 + self.title_margin
    local ymax = ymin + #self.items
    local oldX, oldY = term.getCursorPos()
    for y = ymin, ymax do
	term.setCursorPos(self.x + 1, y)
	term.write(" ")
    end
    term.setCursorPos(oldX, oldY)
end

-----
-- class Form
-- 	super Panel
-----



-----
-- class Map
-- A 3D map with waypoints
-----

Map = {}
Map.__index = Map

function Map.new()
    local map = utils.obj.new(Map)
    map.points = {}
    map.nodes = {}
    map.waypoints = {}
    return map
end

function Map.new_from_file(file)
    local map = Map.new()

    local str = utils.files.read(file)
    local obj = textutils.unserialize(str)

    map.nodes = {}
    for y, ylst in pairs(obj.nodes) do
	for z, zlst in pairs(ylst) do
	    for x, node in pairs(zlst) do
		map:set_node(MapNode.new(node.x, node.y, node.z, node.symbol, node.walkable))
	    end
	end
    end
    
    map.waypoints = obj.waypoints
    return map
end

function Map:set_node(node)
    if self.nodes[node.y] == nil then
	self.nodes[node.y] = {}
    end
    if self.nodes[node.y][node.z] == nil then
	self.nodes[node.y][node.z] = {}
    end
    self.nodes[node.y][node.z][node.x] = node
end

function Map:get_node(x, y, z)
    if self.nodes[y] == nil or self.nodes[y][z] == nil or self.nodes[y][z][x] == nil then
	self:set_node(MapNode.new(x, y, z, "?", MapNode.states.UNKNOWN))
	return self:get_node(x, y, z)
    end
    return self.nodes[y][z][x]
end

function Map:get_neighbors(node)
    local neighbors = {}
    neighbors[#neighbors + 1] = self:get_node(node.x - 1, node.y, node.z)
    neighbors[#neighbors + 1] = self:get_node(node.x + 1, node.y, node.z)
    neighbors[#neighbors + 1] = self:get_node(node.x, node.y, node.z - 1)
    neighbors[#neighbors + 1] = self:get_node(node.x, node.y, node.z + 1)
    neighbors[#neighbors + 1] = self:get_node(node.x, node.y - 1, node.z)
    neighbors[#neighbors + 1] = self:get_node(node.x, node.y + 1, node.z)
    return neighbors
end

function Map:set_waypoint(x, y, z, id)
    local waypoint = {}
    waypoint.x = x
    waypoint.y = y
    waypoint.z = z
    waypoint.id = id
    self.waypoints[id] = waypoint
end

function Map:save(file)
    utils.files.write(file, textutils.serialize(self))
end

-- A*
function Map:get_path(node_start, node_end)
    node_start.gcost = 0
    node_start.fcost = self:estimate_cost(node_start, node_end)
    local openset = {node_start}
    local closedset = {}
    local came_from = {}

    while not moz.utils.tables.is_empty(openset) do
	local current = self:get_min_fcost(openset)
	if current == node_end then
	    local path = {}
	    self:build_path(came_from, node_end, path)
	    return utils.tables.reverse(path)
	end

	moz.utils.tables.remove(openset, current)
	closedset[#closedset + 1] = current
	
	for i, neighbor in ipairs(self:get_neighbors(current)) do
	    if neighbor.state ~= MapNode.states.BLOCK then
		if not moz.utils.tables.has(closedset, neighbor) then
		    local gcost = current.gcost + 1
		    if not moz.utils.tables.has(openset, neighbor) or  gcost <= neighbor.gcost then
			came_from[neighbor] = current
			neighbor.gcost = gcost
			neighbor.fcost = self:estimate_cost(neighbor, node_end)
			if not moz.utils.tables.has(openset, neighbor) then
			    openset[#openset + 1] = neighbor
			end
		    end
		end
	    end
	end
    end
    return nil
end

function Map:estimate_cost(node, node_end)
    local cost = node.gcost + (math.floor(moz.utils.gps.get_distance(node, node_end))*2)
    if node.state == MapNode.states.UNKNOWN then
	cost = cost + 10
    end
    return cost
end

function Map:build_path(came_from, node, path)
    path[#path + 1] = node
    if came_from[node] ~= nil then
	return self:build_path(came_from, came_from[node], path)
    else
	return node
    end
end

function Map:get_min_fcost(set)
    local min = nil
    for i, node in ipairs(set) do
	if min == nil or node.fcost <= min.fcost then
	    min = node
	end
    end
    return min
end

--
-- MapNode
-- elementary element of a Map
--

MapNode = {}
MapNode.__index = MapNode

function MapNode.new(x, y, z, symbol, state)
    local node = moz.utils.obj.new(MapNode)
    node.x = x
    node.y = y
    node.z = z
    node.symbol = symbol
    node.state = state
    return node
end

function MapNode:to_s()
    return "(" .. self.x .. ", " .. self.y .. ", " .. self.z .. ")"
end

MapNode.states = {}
MapNode.states.EMPTY = 0
MapNode.states.UNKNOWN = 1
MapNode.states.BLOCK = 2

-----
-- class MapViewer
--
-- display a view of a map z layer
-----

MapViewer = {}
MapViewer.__index = MapViewer

function MapViewer.new(width, height)
    local self = utils.obj.new(MapViewer)
    self.width = width
    self.height = height
    return self
end

function MapViewer:to_lines(map, origX, origY, origZ)
    local minX = origX - math.floor(self.width / 2)
    local maxX = origX + math.floor(self.width / 2)
    local minZ = origZ - math.floor(self.height / 2)
    local maxZ = origZ + math.floor(self.height / 2)

    local view = self:view(map, origX, origY, origZ)
    local lines = {}
    i = 1
    for z = minZ, maxZ do
	lines[i] = ""
	for x = minX, maxX do
	    lines[i] = lines[i] .. view[z][x]
	end
	i = i + 1
    end
    return lines
end

function MapViewer:view(map, origX, origY, origZ)

    local minX = origX - math.floor(self.width / 2)
    local maxX = origX + math.floor(self.width / 2)
    local minZ = origZ - math.floor(self.height / 2)
    local maxZ = origZ + math.floor(self.height / 2)

    -- build view
    local lines = self:grid(map, minZ, maxZ, minX, maxX, origX, origY, origZ)
    local layer = map.nodes[origY]
    
    for z = minZ + 1, maxZ - 1 do
	for x = minX + 1, maxX - 1 do
	    if layer ~= nil and layer[z] ~= nil and layer[z][x] ~= nil then
		lines[z][x] = layer[z][x].symbol
	    else
		lines[z][x] = " "
	    end
	end
    end

    for id, waypoint in pairs(map.waypoints) do
	if waypoint.z >= minZ and waypoint.z <= maxZ then
	    if waypoint.x >= minX and waypoint.x <= maxX then
		lines[waypoint.z][waypoint.x] = string.sub(tostring(waypoint.id), 1, 1)
	    end
	end
    end
    return lines
end

function MapViewer:grid(map, minZ, maxZ, minX, maxX, origX, origY, origZ)
    local lines = {}
    for z = minZ, maxZ do
	lines[z] = {}
	for x = minX, maxX do
	    if z == minZ or z == maxZ then
		if x == minX or x == maxX then
		    lines[z][x] = "+"
		elseif z == minZ and x == math.floor((minX + maxX) / 2) then
		    lines[z][x] = "N"
		elseif z == maxZ and x == math.floor((minX + maxX) / 2) then
		    lines[z][x] = "S"
		else
		    lines[z][x] = "-"
		end
	    else
		if x == minX or x == maxX then
		    if x == minX and z == math.floor((minZ + maxZ) / 2) then
			lines[z][x] = "W"
		    elseif x == maxX and z == math.floor((minZ + maxZ) / 2) then
			lines[z][x] = "E"
		    else
			lines[z][x] = "|"
		    end
		else
		    lines[z][x] = " "
		end
	    end
	end
    end

    -- add waypoints on edges
    local edges = self:get_edges(minX, maxX, minZ, maxZ)
    local a = {}
    a.x = origX
    a.z = origZ
    local b = {}
    for id, waypoint in pairs(map.waypoints) do
	if waypoint.x < minX or waypoint.x > maxX or waypoint.z < minZ or waypoint.z > maxZ then
	    b.x = waypoint.x
	    b.z = waypoint.z
	    for j, edge in pairs(edges) do
		
		local c = {}
		local d = {}
		c.x = edge[1]
		c.z = edge[2]
		d.x = edge[3]
		d.z = edge[4]
	    
		local x, z = self:get_intersec(a, b, c, d)
		if x ~= nil and z ~= nil then
		    if lines[z] ~= nil then
			lines[z][x] = waypoint.id
		    end
		end
	    end
	end
    end
    return lines
end

function MapViewer:get_legend(map, origX, origY, origZ)
    local lines = {}
    local orig = {}
    orig.x = origX
    orig.y = origY
    orig.z = origZ
    --lines[#lines + 1] = "orig x:" .. orig.x .. " y: " .. orig.y .. " z:" .. orig.z
    for i, waypoint in pairs(map.waypoints) do
	line = id .. " x:" .. waypoint.x .. " y:" .. waypoint.y .. " z:" .. waypoint.z .. " d:" .. utils.gps.get_distance(orig, waypoint)
	lines[#lines + 1] = line
    end
    return lines
end

function MapViewer:get_edges(minX, maxX, minZ, maxZ)
    local edges = {}
    edges.top = {minX, minZ, maxX, minZ}
    edges.right = {maxX, minZ, maxX, maxZ}
    edges.bottom = {minX, maxZ, maxX, maxZ}
    edges.left = {minX, minZ, minX, maxZ}
    return edges
end

function MapViewer:get_intersec(a, b, c, d)
    local di = (a.x - b.x) * (c.z - d.z) - (a.z - b.z) * (c.x - d.x)
    if di == 0 then return nil end
    local xi = ((c.x - d.x) * (a.x * b.z - a.z * b.x) - (a.x - b.x) * (c.x * d.z - c.z * d.x)) / di
    local zi = ((c.z - d.z) * (a.x * b.z - a.z * b.x) - (a.z - b.z) * (c.x * d.z - c.z * d.x)) / di
    
    if (xi < math.min(c.x, d.x) or xi > math.max(c.x, d.x)) then return nil end
    if (xi < math.min(a.x, b.x) or xi > math.max(a.x, b.x)) then return nil end
    if (zi < math.min(c.z, d.z) or zi > math.max(c.z, d.z)) then return nil end
    if (zi < math.min(a.z, b.z) or zi > math.max(a.z, b.z)) then return nil end
    return math.floor(xi), math.floor(zi)
end

-----
-- utils
-----

utils = {}

--
-- rednet
--

utils.rednet = {}

-- serialize and send a message over rednet
function utils.rednet.sendMessage(message)
    rednet.send(message.target, textutils.serialize(message))
end

-- serialize and broadcast a message over rednet
function utils.rednet.broadcastMessage(message)
    rednet.broadcast(textutils.serialize(message))
end

--
-- obj
--

utils.obj = {}

-- call a method on a receiver
function utils.obj.call(recv, method_name, params)
    if getmetatable(recv)[method_name] ~= nil then
	return getmetatable(recv)[method_name](recv, params)
    else
	print("ERROR: no method called '".. tostring(method_name) .."' in table.")
	return nil
    end
end

function utils.obj.new(class, super)
    if super ~= nil then
	-- Inherit methods from superclasse
	for i, j in pairs(getmetatable(super)) do
	    if class[i] == nil then class[i] = j end
	end
    end
    
    local obj = {}
    setmetatable(obj, class)

    if super ~= nil then
	-- Inherit attributes from Panel
	for i, j in pairs(super) do
	    if obj[i] == nil then obj[i] = j end
	end
    end
    return obj
end

--
-- gps
--
utils.gps = {}

function utils.gps.getCoords()
    x, y, z = gps.locate(1, false)
    coords = {}
    coords.x = x
    coords.y = y
    coords.z = z
    return coords
end

function utils.gps.get_distance(a, b)
    return math.sqrt( (b.x - a.x)^2 + (b.y - a.y)^2 + (b.z - a.z)^2 )
end

--
-- files
--

utils.files = {}

function utils.files.file_exists(file)
    ptr = io.open(file, "r")
    return ptr ~= nil
end

function utils.files.read(file, str)
    if not utils.files.file_exists(file) then
	print("Error: Map file not found.")
	return
    end

    local ptr = io.open(file, "r")
    local str = ptr:read("*a")
    ptr:close()
    return str
end

function utils.files.write(file, str)
    ptr = io.open(file, "w")
    ptr:write(str)
    ptr:close()
end

--
-- tables
--

utils.tables = {}

function utils.tables.remove(tbl, elem)
    idx = nil
    for i, e in ipairs(tbl) do
	if e == elem then
	    idx = i
	end
    end
    table.remove(tbl, idx)
end

function utils.tables.has(tbl, elem)
    for i, e in ipairs(tbl) do
	if e == elem then
	    return true
	end
    end
    return false
end

function utils.tables.is_empty(tbl)
    count = 0
    for i, e in ipairs(tbl) do
	count = count + 1
    end
    return count == 0
end

function utils.tables.reverse(tbl)
    reversed = {}
    for idx = 0, #tbl - 1 do
	reversed[#reversed + 1] = tbl[#tbl - idx]
    end
    return reversed
end

-----
--- LinkedList
-----

LinkedList = {}
LinkedList.__index = LinkedList

function LinkedList.new()
    local self = moz.utils.obj.new(LinkedList)
    self.head = nil
    self.tail = nil
    return self
end

function LinkedList:is_empty()
    return self.head == nil
end

function LinkedList:prepend(value)
    local node = {}
    node.value = value
    node.prev = nil
    node.next = self.head

    self.head = node

    if node.next ~= nil then
	node.next.prev = node
    end

    if self.tail == nil then
	self.tail = node
    end
end

function LinkedList:prepend_all(values)
    for k, v in pairs(values) do
	self:prepend(v)
    end
end

function LinkedList:insert_at(idx, value)
    local node = {}
    node.value = value
    node.prev = nil

    local next = self:get_node_at(idx)
    if next ~= nil then
	next.prev.next = node
	node.prev = next.prev
    
	next.prev = node
	node.next = next
    end

    if self.head == nil then
	self.head = node
    end
    
    if self.tail == nil then
	self.tail = node
    end
end

function LinkedList:append(value)
    local node = {}
    node.value = value
    node.prev = self.tail
    node.next = nil

    self.tail = node

    if node.prev ~= nil then
	node.prev.next = node
    end

    if self.head == nil then
	self.head = node
    end
end

function LinkedList:append_all(values)
    for k, v in pairs(values) do
	self:append(v)
    end
end

function LinkedList:get_node_at(index)
    local idx = 0
    local node = self.head
    
    while node ~= nil do
	idx = idx + 1
	if idx == index then
	    return node
	end
	node = node.next
    end
    return nil
end

function LinkedList:get(index)
    return self:get_node_at(index).value
end

function LinkedList:first()
    if not self:is_empty() then
	return self.head.value
    end
    return nil
end

function LinkedList:last()
    if not self:is_empty() then
	return self.tail.value
    end
    return nil
end

function LinkedList:pop_first()
    if not self:is_empty() then
	local first = self.head
	local next = self.head.next
	if next ~= nil then
	    next.prev = nil
	end
	self.head = next
	return first.value
    end
    return nil
end

function LinkedList:pop_last()
    if not self:is_empty() then
	local last = self.tail
	local prev = last.prev
	if prev ~= nil then
	    prev.next = nil
	else
	    self.head = nil
	end
	self.tail = prev
	return last.value
    end
    return nil
end

function LinkedList:clear()
    self.head = nil
    self.tail = nil
end

function LinkedList:as_array()
    local items = {}

    local node = self.head
    while node ~= nil do
	items[#items + 1] = node.value
	node = node.next
    end
    return items
end